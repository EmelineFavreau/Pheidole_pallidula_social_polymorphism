---
title: "Expected likelihood for simulated SNPs (Solenopsis model)"
author: "Emeline Favreau"
date: "27 August 2019"
output:
  pdf_document: default
  html_document: default
---

We took **3,757 real SNPs** (100% sample-coverage, in coding regions, within-population polymorphic, from 108 diploid workers, each representative of one colony, from one of the following regions: France: 69 samples, 16 monogynous and 53 polygynous; Italy: 23 samples, 16 monogynous and 7 polygynous; Pyrenees: 16 samples, 5 monogynous and 11 polygynous.
Based on Pracana et al 2017, 2,5% SNPs are fixed in _Solenopsis invicta_ supergene region. We therefore added **95 simulated SNPs** to the dataset.
The simulated SNPs represent what we expect from the supergene system: homozygous SNPs for monogynous and 1/3 of polygynous samples, heterozygous SNPs for 2/3 of polygynous.

We performed a Fisher test of allele count for each SNP between monogynous samples and polygynous samples and adjusted the p-values for multiple comparisons (Benjamini & Hochberg). 
All simulated SNPs are significantly associated with social type. To independently test this finding, here we use two statistical tests based on the likelihood of a SNP to vary accordingly to the _Solenopsis invicta_ system. The input dataset is the SNP matrix obtained with bcftools.



```{r import data and libraries, eval = TRUE, echo = FALSE, include = FALSE}
# import SNP matrix and sample vector
snp_matrix <- read.csv(file = "2019-04-02-addfakesnp/result/2019-08-23-flye-Pheidole-genic-fake-Solenopsis-snps-snp_matrix.txt", header = FALSE, sep = "\t")
sample_list_vec <- read.table(file = "2019-04-02-addfakesnp/result/2019-08-23-flye-Pheidole-genic-fake-Solenopsis-snps-sample_names.txt", header = FALSE, sep = "")


# load all the libraries
# get libraries
basic_libraries <- c("qqman", "ggplot2", "gridExtra", "LDheatmap", "hrbrthemes")
for (lib in basic_libraries) {
        if (require(package = lib, character.only = TRUE)) {
                print("Successful")
        } else {
                print("Installing")
                install.packages(lib)
                library(lib, character.only = TRUE )
        }
}
```


```{r setting up the matrix, eval = TRUE, echo = FALSE}
# keep the snp ids in a vector
snp_id <- as.vector(snp_matrix[, 1])

# keep the position of the loci
loci_and_position_table <- snp_matrix[, 1:2]
colnames(loci_and_position_table ) <- c("SNPid", "position")

# remove first two rows (uninformative, snp id and location)
# head(snp_matrix)
snp_matrix1 <- snp_matrix[, 3:ncol(snp_matrix)]

# Turn the matrix on its side (rows = individuals, columns = loci)
snp_matrix1t <- t(snp_matrix1)

# change the sample names for biological names by sourcing the 46 colony names
colnames(sample_list_vec) <- "sample_name"
colony_names <- as.character(sample_list_vec$sample_name)

# change 4 sample names to the right genotype
colony_names <- gsub(pattern = "I27-N", replacement = "I27-P", x = colony_names)
colony_names <- gsub(pattern = "A56-N", replacement = "A56-M", x = colony_names)
colony_names <- gsub(pattern = "andrea-N", replacement = "andrea-P", x = colony_names)
colony_names <- gsub(pattern = "muna-N", replacement = "muna-P", x = colony_names)

# make the sample names in the matrix row biologically meaningful
row.names(snp_matrix1t) <- colony_names

# make the snp_id in the matrix column meaningful
colnames(snp_matrix1t) <- snp_id

# subset the colony names for each genotype
M <- as.character(colony_names[grep("M$", colony_names)])
M_sample_num <- length(M)
P <- as.character(colony_names[grep("P$", colony_names)])
P_sample_num <- length(P)

# reorder the rows by population 
snp_matrix2 <- snp_matrix1t[c(M, P), ]

# check the different types of genotypes by uncommenting the following line
# unique(as.vector(unlist(snp_matrix2))) 
# "0/1" "0/0" "./." "1/1"
# transform the matrix content so that genotypes are coded as alternative allele count
# example: in the vcf file 0/0 means that both alleles are reference 
# so I code this as 0 alternative alleles
snp_matrix2 <- as.matrix(snp_matrix2)
snp_matrix2[snp_matrix2 == "0/0"] <- 0 
snp_matrix2[snp_matrix2 == "0/1"] <- 1
snp_matrix2[snp_matrix2 == "./."] <- NA
snp_matrix2[snp_matrix2 == "1/1"] <- 2

# sanity check: genotypes are changed into the wanted code (but character class)
# snp_matrix2[1:2, 1:2]
# change class of each genotype, from character to numeric
snp_matrix2df <- as.data.frame(apply(snp_matrix2, 2, as.numeric), row.names = rownames(snp_matrix2))

# sanity check
fake_snps <- grep(colnames(snp_matrix2df), pattern = "fake.*", value = TRUE)
fake_snps_mat <- subset(snp_matrix2df, select = colnames(snp_matrix2df) %in% fake_snps)
```

The analysis based on Fisher test of allele count detected all 95 fake SNPs. 

An alternative method is comparing the expected and observed genotype probabilities, based on a density binomial test. 
Any deviant from the genome wide average are expected to be the fake SNPs.

## Test 1: strict model for polygynous samples

The first test here focus on the likelihood of a SNP to be normal (L1) and to be diagnostic (L2).
A diagnostic SNP will present: all monogynous and 1/3 polygynous are homozygous; 2/3 polygynous are heterozygous.


```{r likelihood test, eval = TRUE, echo = FALSE}

# make result matrix
diagnostic_result_mat <- matrix(NA, nrow = length(snp_id), ncol = 3)

# looping through each locus
for(locus_position in 1:length(snp_id)){
  
        # obtain genotype for one locus (that will be the vector of quantile for the binomial test)
        genotype_vec <- unlist(subset(snp_matrix2df, select = colnames(snp_matrix2df) == snp_id[locus_position]))
        
        # name the vector by the social type
        names(genotype_vec) <- gsub(rownames(snp_matrix2df), pattern = ".+-", replacement = "")

        # establish the population frequency of not getting the reference allele
        number_of_all_possible_outcomes <- sum(!is.na(genotype_vec))*2
        
        # calculate the probability of a nucleotide not being the reference (ie not 0)
        prob_being_alternative <- sum(genotype_vec, na.rm = TRUE) / number_of_all_possible_outcomes
        
        # create a factor with social type
        mp_fact <- factor(names(genotype_vec), levels = c("M", "P"))
        
        # remove NAs
        mp_fact_noNA <- mp_fact[!is.na(genotype_vec)]
        genotype_vec_noNA <- genotype_vec[!is.na(genotype_vec)]
        
        # We first calculate L1, the probability of the variant in our dataset to be non-diagnostic
        # the outcome: success of genotype BB (coded 0) or failure (Bb coded 1, bb coded 2)
        # calculate the sum of logged density of binomial distribution
        normal_snp_likelihood_L1 <- sum(
                 # x = the probability associated with all genotypes are exactly what they are
          dbinom(x    = genotype_vec_noNA,
                 # size = 2 (nb of trials: each allele from a diploid allele can be reference or alternative)
                 size = 2,
                 # prob = of being the alternative
                 prob = prob_being_alternative,
                 log  = TRUE)
          )
        
        # We then create a function for the expected logged probabilities (likelihood 2)
        
        # for monogynous samples, expected supergene value is 1 (when genotype is BB)
        # all other genotypes (Bb bb) is coded as 0
        # for polygynous samples, expected values are:
        # 1 for genotypes 0 (BB) and 1 (Bb), at a frequency of 1/3 and 2/3
        # 0 for genotype 2 (bb)
        
        # the function takes the genotype vector of the locus, plus the gyny factor
        L2_calculator <- function(genotype_vec_noNA, mp_fact_noNA){
          
           
           # set the result vector, assumption: probability is 0 for all samples
           this_locus_score <- rep(0, length(genotype_vec_noNA))
        
           # set the score for the monogynous samples that are reference (change code 0 for 1)
           this_locus_score[(mp_fact_noNA == "M") & (genotype_vec_noNA == 0)] <- 1
        
           # two-third of the polygynous are expected to be supergene Bb
           this_locus_score[(mp_fact_noNA == "P") & (genotype_vec_noNA == 1)] <- 2/3
        
           # one-third of the polygynous are expected to be supergene BB
           this_locus_score[(mp_fact_noNA == "P") & (genotype_vec_noNA == 0)] <- 1/3
        
           # return the sum of logged probabilities
           return(sum(log(this_locus_score)))
        }
        
        # run the function on the data
        diagnostic_snp_likelihood_L2 <- L2_calculator(genotype_vec_noNA, mp_fact_noNA)
        
        # if return -INF, the SNP is not diagnostic (ie is not behaving like simulated SNP with all M BB, 1/3P BB, 2/3P Bb)
        # because: some M samples are not reference (ie have a probability of 0 to be reference)
        # because: some P samples are homozygote for alternative bb (ie have a probability of 0 to be reference)
        
        # compile the result: SNP name, L2, L1
        this_result <- c(snp_id[locus_position], diagnostic_snp_likelihood_L2, normal_snp_likelihood_L1)
     
        # save results
        diagnostic_result_mat[locus_position, ] <- this_result
}

# change to dataframe
diagnostic_result_df <- as.data.frame(diagnostic_result_mat, stringsAsFactors = FALSE)

# name columns
colnames(diagnostic_result_df) <- c("SNP", "L2", "L1")

# change class
diagnostic_result_df$L2 <- as.numeric(diagnostic_result_df$L2)
diagnostic_result_df$L1 <- as.numeric(diagnostic_result_df$L1)

# make diagnostic statement L2 - L1
diagnostic_result_df$L2L1diff <- diagnostic_result_df$L2 - diagnostic_result_df$L1

# add a column for SNP status
diagnostic_result_df$SNP_status <- ifelse(diagnostic_result_df$SNP %in% fake_snps, "fake", "real")

# report distribution of L2L1diff for fake SNPs
print("All simulated SNPs have a likelihood difference")
summary(subset(diagnostic_result_df, subset = SNP %in% fake_snps, select = L2L1diff))
#plot(unlist(subset(diagnostic_result_df, subset = SNP %in% fake_snps, select = L2L1diff)))

# report distribution of L2L1diff for real SNPs
print("All real SNPs have no likelihood difference (-INF)")
summary(subset(diagnostic_result_df, subset = !(SNP %in% fake_snps), select = L2L1diff))
# plot(unlist(subset(diagnostic_result_df, subset = !(SNP %in% fake_snps), select = L2L1diff)))
# 
# ggplot(data = diagnostic_result_df, aes(x = L2L1diff, group = SNP_status, fill = SNP_status)) +
#     geom_density(adjust = 1.5, alpha = .4) +
#     theme_classic()
# 
# ggplot(data = diagnostic_result_df, aes(x = L2L1diff, group = SNP_status, fill = SNP_status)) +
#     geom_histogram(alpha = .4, binwidth = 1) +
#     theme_classic()

```

The likelihood of being a simulated SNP is strikingly different than the likelihood of being a normal SNP, as seen on the L2 L1 difference.

An alternative to this test is to relax the expected genotypes of polygynous.
Instead of execting exactly 1/3 homozygote and 2/3 heterozygote, we set a rule: polygynous diploid samples should have no homozygous for the alternative allele at a diagnostic locus. The monogynous samples should be homozygous for the reference.

## Test 2: relaxed model for polygynous samples

**Richard's email:**
I had an idea for a more robust test. 
Even if you don’t expect exactly 1/3 : 2/3  heterozygotes to homozygotes in Polygynes, you can calculate a p-value based on the rules that 
Monogyne are all 0/0 and 
Polygynes are 0/0 or 0/1 but not 1/1 

That means that all ‘1's must occur in polygyne, and not in double copy … so if you have 20 monogyne and 80 polygyne and x ‘1' alleles,  you can imagine allocating the d alleles according to that rule.

The first one must be allocated to one of the 80 polygyne individuals.  That is with probability 80/100.
The second must be allocated to one of the remaining polygyne individuals with probability 79/100 etc.

We can write the combined probability as 80 x 79 … (80 - x + 1)  / 100^x
We can use a common probability trick to write this as 80! / (80-x)! / 100^x

I’ve written a function to return this value for the loci that obey the rules (or NA for other loci).
https://www.dropbox.com/s/tl93rjvzuhepc34/pcalc.R?dl=0

That file also has some example data to show that this gives a much lower p-value than a fisher.test.

```{r rule no double copy of 1 in polygynous, eval = FALSE, echo = FALSE}

# p-value for putative markers of social inversion based on randomisation logic
pcalc <- function(genotypes,
                  mpFactor){
  # remove NAs
  mpFactor <- mpFactor[!is.na(genotypes)]
  genotypes <- genotypes[!is.na(genotypes)]
  
  # calculate number of sites
  nsites <- length(genotypes)
  
  # calculate number of polygynous sites
  allowedSites <- sum(mpFactor == 'P')
  
  # check if there are het/alt hom in monogynous
  if (sum(genotypes[mpFactor == 'M']) > 0) return(NA)
  
  # check if there are alt hom in any samples
  if (sum(genotypes == 2) > 0) return(NA)
  
  # calculate number of alternative allele
  alleleCount <- sum(genotypes)
  
  # binomial distribution equation * 1/(nsites^alleleCount)
  p <- factorial(allowedSites)/factorial(allowedSites - alleleCount) / (nsites^alleleCount)
  
  # return the p-value
  return(p)   
}

# simple test data
# 20 Monogyne and 80 polygyne
M_num <- 20
P_num <- 80
mpfact <- factor(c(rep('M', M_num), rep('P', P_num)))

# create genotypes (100 diploid individuals)
gtypes <- rep(0, 100)

# make genotypes 1/3 hets in polygynes
gtypes[mpfact == 'P'] <- rbinom(P_num, size = 1, prob = 1/3)

# return the p-value for putative SNP
pcalc(gtypes, mpFactor = mpfact)

# test with a Fisher Test of allele count 
# (20*2 M ref, 0 M alt, 80*2*2/3 P ref, 80*2*2/3 P alt)
fisher.test(cbind(c((M_num*2), 0),
                  c((P_num*2) - sum(gtypes), sum(gtypes))), 
            alternative = 'greater'
            )$p.value


```

Testing with real and simulated data.

```{r applying rule no double copy of 1 in polygynous, eval = TRUE, echo = FALSE}

# p-value for putative markers of social inversion based on randomisation logic
pcalc <- function(genotypes, mpFactor){
  # remove NAs
  mpFactor <- mpFactor[!is.na(genotypes)]
  genotypes <- genotypes[!is.na(genotypes)]
  
  # calculate number of sites
  nsites <- length(genotypes)
  
  # calculate number of polygynous sites
  allowedSites <- sum(mpFactor == 'P')
  
  # check if there are het/alt hom in monogynous
  if (sum(genotypes[mpFactor == 'M']) > 0) return(NA)
  
  # check if there are alt hom in any samples
  if (sum(genotypes == 2) > 0) return(NA)
  
  # calculate number of alternative allele
  alleleCount <- sum(genotypes)
  
  # binomial distribution equation * 1/(nsites^alleleCount)
  p <- factorial(allowedSites)/factorial(allowedSites - alleleCount) / (nsites^alleleCount)
  
  # return the p-value
  return(p)   
}

# create a matrix with the result
no_double_copy_test_result <- matrix(NA, ncol = 2, nrow = length(snp_id))

# loop through each locus
for(snp_position in 1:length(snp_id)){

    # obtain genotype for one locus (that will be the vector of quantile for the binomial test)
    genotype_vec <- unlist(subset(snp_matrix2df, select = colnames(snp_matrix2df) == snp_id[snp_position]))
            
    # name the vector by the social type
    names(genotype_vec) <- gsub(rownames(snp_matrix2df), pattern = ".+-", replacement = "")
    
    # factor of social type
    mpfact <- factor(names(genotype_vec), levels = c("M", "P"))
    
    # return the p-value for putative SNP (NA means that it is not a diagnostic snp)
    p_val <- pcalc(genotypes = genotype_vec, mpFactor = mpfact)
    
    # save result in df
    no_double_copy_test_result[snp_position, ] <- c(snp_id[snp_position], p_val)
}

# change to dataframe
no_double_copy_test_result_df <- as.data.frame(no_double_copy_test_result, stringsAsFactors = FALSE)

# name columns
colnames(no_double_copy_test_result_df) <- c("SNP", "p_value")

# add SNP status
no_double_copy_test_result_df$SNP_status <- ifelse(no_double_copy_test_result_df$SNP %in% fake_snps, "fake", "real")

# change class
no_double_copy_test_result_df$p_value <- as.numeric(no_double_copy_test_result_df$p_value)

# report distribution of L2L1diff for fake SNPs
print("All simulated SNPs have a p-value lower than 0.05")
summary(subset(no_double_copy_test_result_df, subset = SNP %in% fake_snps, select = p_value))


# report distribution of L2L1diff for real SNPs
print("All real SNPs have a NA result, meaning that monogynous are het or any sample is alt hom")
summary(subset(no_double_copy_test_result_df, subset = !(SNP %in% fake_snps), select = p_value))

```

# Conclusion

Both the first test (strict rule about proportions of hom and het in polygynous) and the second test (no double copies in polygynous rule) flag out the simulated SNPs.
All real SNPs do not pass any of the diagnotic tests.